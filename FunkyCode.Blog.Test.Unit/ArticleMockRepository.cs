using System;
using System.Collections.Generic;
using System.Text;
using Microsoft.IdentityModel.Tokens;

namespace FunkyCode.Blog.Test.Unit
{
    public class ArticleMockRepository
    {

        public static string GetCreateCommandLineToolArticleContent()
        {
            return
                "﻿# Create Command Line Tool\r\n\r\n<!-- Id: create-cmd-line-tool -->\r\n<!-- Categories: Git -->\r\n<!-- Date: 20200331 -->\r\n\r\n<!-- #header -->\r\nTasks such as copying files and folders, compressing files, running unit tests and so on I used to fulfill via batch, PowerShell or [Cake](https://cakebuild.net/). I was wondering why not just to use .NET Core Console App and take advantage of great libraries to create full fledged scripting engine.\r\n<!-- #endheader -->\r\n\r\nThis post is part of series:\r\n1. [Hello Git Hooks](/post/git-hooks)\r\n2. Create command line tool\r\n3. [Git API](/post/git-api)\r\n\r\nIn [previous post](/post/git-hooks) I introduced Git Hooks - handlers for Git events which I intend to use to check content of the files which are about to be commited. So far I grasp only moment before commit is executed and promised to write logic in ```C#```.\r\nGit Hook will _only_ invoke my ```command line tool``` which I create.\r\n\r\nThe simpliest command line tool is to create ```Console App``` project \r\n\r\n![03](03.png)\r\n\r\nand manually parse incomming parameters which will come in ```args``` array.\r\n\r\n``` csharp\r\nclass Program\r\n{\r\n    static void Main(string[] args)\r\n    {\r\n        // You can parse args if you want but better use dedicated library\r\n    }\r\n}\r\n```\r\n\r\nBut for sure better way is to use dedicated library for handling all concerns regarding parameters - shortcuts, help, validation, default values etc. Personally, I use simple yet very effective and friendy [CommandLineParser](https://github.com/commandlineparser/commandline) tool which helps in managing command line tool arguments.\r\n\r\n![01](01.png)\r\n\r\n.NET Core 3.0 provides [in-built feature](https://docs.microsoft.com/en-usarchive/msdn-magazine/2019/march/net-parse-the-command-line-with-system-commandline) for handling command line parameters, but I will stay with ```CommandLineParser```. I thing this library is much more convenient for use as it is self-descriptive and allows me have all information about parameters and their settings in one file.\r\n\r\n```CommandLineParser``` takes care only for command options, so there is freedom for create contracts for command with respect to their options.\r\n\r\n``` csharp\r\npublic interface IConsoleCommand<in T> where T : OptionsBase\r\n{\r\n    int Execute(T options);\r\n}\r\n```\r\n\r\nOur command will receive working directory as option. ```Verb``` represents alias for our command in case we have many command in single script.\r\n\r\n``` csharp\r\npublic class GitPreCommitCommand : IConsoleCommand<GitPreCommitCommand.Options>\r\n{\r\n    [Verb(\"git-pre-commit\", HelpText = \"Handles git pre-commit hook\")]\r\n    public class Options : OptionsBase\r\n    {\r\n        [Option('d', \"directory\", Required = true, HelpText = \"Git working directory\")]\r\n        public string WorkingDirectory { get; set; }\r\n    }\r\n\r\n    public int Execute(Options options)\r\n    {\r\n        /// TODO: implement in next post :)\r\n        /// (...)\r\n    }\r\n}\r\n```\r\n\r\nHere's place where commands can be bind with input parameters. I also will use [Autofac](https://autofac.org/) for handling dependency injection.\r\n\r\n``` csharp\r\ninternal class Program\r\n{\r\n    public static int Main(string[] args)\r\n    {\r\n        return Parser.Default.ParseArguments<UploadBlogArticleCommand.Options, GitPreCommitCommand.Options>(args)\r\n            .MapResult(\r\n                (UploadBlogArticleCommand.Options opts) => DoExecute(opts),\r\n                (GitPreCommitCommand.Options opts) => DoExecute(opts),\r\n                errs => 1);\r\n    }\r\n\r\n    static int DoExecute<TOptions>(TOptions options) where TOptions : OptionsBase\r\n    {\r\n        try\r\n        {\r\n            using var container = ConfigureContainer();\r\n            using var scope = container.BeginLifetimeScope();\r\n            var command = scope.Resolve<IConsoleCommand<TOptions>>();\r\n            return command.Execute(options);\r\n        }\r\n        catch (Exception exc)\r\n        {\r\n            Console.WriteLine(exc.Message);\r\n            return 1;\r\n        }\r\n    }\r\n\r\n    static IContainer ConfigureContainer()\r\n    {\r\n        var builder = new ContainerBuilder();\r\n        \r\n        builder.RegisterAssemblyTypes(Assembly.GetExecutingAssembly())\r\n            .AsImplementedInterfaces()\r\n            .InstancePerLifetimeScope();\r\n        \r\n        var container = builder.Build();\r\n        \r\n        return container;\r\n    }\r\n}\r\n\r\n```\r\n\r\nWhen aplication is compiled and executed, ```CommandLineParser``` will take care of handling arguments input.\r\n\r\n![04](04.png)\r\n\r\nCommand line tool is almost ready, only what is to be done is to make is executable single file.\r\n\r\nI use [dotnet-warp](https://github.com/Hubert-Rybak/dotnet-warp) tool which is recommened by Scott Hanselman in this [post](https://www.hanselman.com/blog/MakingATinyNETCore30EntirelySelfcontainedSingleExecutable.aspx).\r\nTool should be run in folder which contains ```.sln``` or ```.csproj``` file.\r\n\r\n``` code\r\ndotnet tool install -g dotnet-warp\r\ndotnet-warp\r\n```\r\n\r\nSo far it's manual process, but after building project, it's only to type ```dotnet-warp``` to create single executable file.\r\n\r\nWe have now just engine for commands. It can be applied one by one to this engine along with need that would occur during project evolvement. But just now this executable file can be bound with ```pre-commit``` hook.\r\n\r\n``` code \r\n#!/bin/sh\r\n\r\necho \"executing pre-commit\"\r\n\r\nset -e\r\n\r\n./FunkyCode.Blog.Inf.ScriptEngine/funky-scripts.exe git-pre-commit -d c:/Projects/Tools/BlogEngine\r\n```\r\n\r\nOk, now we have our command line tool executed whenever ```git commit``` is about to be perfomed. Still theres no logic, but this will be completed in [next post](/post/git-api).\r\n\r\n\r\n    \r\n\r\n\r\n\r\n\r\n\r\n\r\n";
        }

        public static string GetCreateCommandLineToolArticleFragment(string headerContent)
        {
            return
                $"﻿# Create Command Line Tool\r\n\r\n<!-- Id: create-cmd-line-tool -->\r\n<!-- Categories: Git -->\r\n<!-- Date: 20200331 -->\r\n\r\n<!-- #header -->\r\n{headerContent}\r\n<!-- #endheader -->";
        }

    }
}
